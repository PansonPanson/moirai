客户端向服务端发送请求，服务端并不会立刻回复响应，而是 hold 请求，也就是把请求先挂起，等待固定的时间之后，也许是 10 秒，也许是 30 秒，再异步回复客户端响应。

在服务端挂起客户端请求的过程中，如果用户在 web 界面修改了线程池信息，那么服务端就可以直接回复客户端响应，通知客户端进行线程池配置变更。

当然，如果本次请求客户端并没有发现需要进行配置变更的线程池，客户端在收到服务端回复的空响应之后，就会立即发送新的请求，就这样循环下去即可。
这就是长轮询请求的工作模式。

```mermaid
flowchart TD
    A[客户端订阅3个线程池配置] --> B[ClientWorker 中创建 3 个 CacheData 对象]
    B --> C[准备发送长轮询请求]

    C --> D[将每个线程池的信息（命名空间、itemId、threadPoolId、identify、md5）拼接成字符串]
    D --> E[拼接成一个总字符串，一次性发送给服务端]

    E --> F[服务端接收请求，解析字符串获取每个线程池的 md5 信息]
    F --> G[与服务端最新配置 md5 做对比]
    G --> H{是否有配置变更？}

    H -- 是 --> I[服务端返回发生变更的线程池标识（命名空间、itemId、threadPoolId）]
    H -- 否 --> Z[返回空响应，客户端继续等待]

    I --> J[客户端收到响应，提取线程池标识信息]
    J --> K[客户端主动请求服务端获取该线程池最新配置]
    K --> L[获取到最新配置并计算 md5]

    L --> M{与 CacheData 中的 md5 是否一致？}
    M -- 不一致 --> N[触发回调方法，更新本地线程池配置]
    M -- 一致 --> O[不执行回调，等待下次变更]

    Z --> C  --> loopStart((重新发起长轮询请求))
    N --> loopStart
    O --> loopStart
```